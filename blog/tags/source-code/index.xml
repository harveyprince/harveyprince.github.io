<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jason Lab</title>
    <link>http://harveyprince.github.io/blog/tags/source-code/index.xml</link>
    <description>Recent content on Jason Lab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Jason</copyright>
    <atom:link href="/tags/source-code/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Angular1 Source Code Overview</title>
      <link>http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/</link>
      <pubDate>Thu, 15 Dec 2016 10:18:34 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/</guid>
      <description>&lt;p&gt;基于版本：1.6.0&lt;/p&gt;

&lt;h2 id=&#34;概念解读&#34;&gt;概念解读&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;先来搬运一下官方的doc&lt;/p&gt;

&lt;p&gt;其中介绍了一些框架内的重要概念
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Concept&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Template&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;HTML with additional markup&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Directives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extend HTML with custom attributes and elements&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Model&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the data shown to the user in the view and with which the user interacts&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Scope&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;context where the model is stored so that controllers, directives and expressions can access it&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Expressions&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;access variables and functions from the scope&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Compiler&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;parses the template and instantiates directives and expressions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Filter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;formats the value of an expression for display to the user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;View&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;what the user sees (the DOM)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Data Binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sync data between the model and the view&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Controller&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the business logic behind views&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Dependency Injection&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Creates and wires objects and functions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Injector&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dependency injection container&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Module&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;a container for the different parts of an app including controllers, services, filters, directives which configures the Injector&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Service&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;reusable business logic independent of views&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;这些概念存在的意义&#34;&gt;这些概念存在的意义&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;一个简单的例子&#34;&gt;一个简单的例子&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/beedjLQy1AqlCcgcixuN/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这看起来很像普通的html，加上一些新的标记。在angular中，以这样的形式组织的语句叫做模版。
当Angular启动应用时，它会使用&lt;code&gt;compiler&lt;/code&gt;来转化和处理&lt;code&gt;template&lt;/code&gt;中的新标记。
加载、转化和渲染后的DOM称之为&lt;code&gt;view&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第一种新标记称之为&lt;code&gt;directives&lt;/code&gt;。它们将特殊的行为应用到HTML中的attributes或者elements中。
在这个例子中，我们使用了&lt;code&gt;ng-app&lt;/code&gt;，它用来连接一个&lt;code&gt;directive&lt;/code&gt;来实例化我们的应用。
Angular自身还为&lt;code&gt;input&lt;/code&gt;元素定义了一个directive来扩展该元素的行为。
&lt;code&gt;ng-model&lt;/code&gt;这个directive用来在变量和input filed中同步数据展示，即一个双向绑定。
值得注意的是，在Angular中，&lt;code&gt;directive&lt;/code&gt;是唯一一个可以直接接触DOM的地方。&lt;/p&gt;

&lt;p&gt;第二种新的标记形如&lt;code&gt;{{ expression | filter }}&lt;/code&gt;，当compiler遇到这样的标记时，会用最终的计算结果来代替它。
expression是一个js形式的代码语句，可以读写在该&lt;code&gt;scope&lt;/code&gt;中存活的变量。存储在scope中的变量称之为&lt;code&gt;model&lt;/code&gt;。
这个例子还包含了一个&lt;code&gt;filter&lt;/code&gt;，一个过滤器将数据格式化后展现给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-databinding1.png&#34; alt=&#34;concepts-databinding1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子展现了Angular的一个重要的绑定概念：无论何时当input的value发生了变化，expression中的value也会自动重新计算，
并且将结果更新到DOM中去，这个概念称之为双向数据绑定。&lt;/p&gt;

&lt;h3 id=&#34;一个controller的例子&#34;&gt;一个controller的例子&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/ICBcjB5SPnwqOUaegQQg/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们引入了&lt;code&gt;controller&lt;/code&gt;，使用controller的目的是为了将一些变量和功能性的方法暴露给&lt;code&gt;expressions&lt;/code&gt;和&lt;code&gt;directives&lt;/code&gt;。
我们在HTML中使用了&lt;code&gt;ng-controller&lt;/code&gt;这个directive，这个directive告诉Angular一个新的&lt;code&gt;InvoiceController&lt;/code&gt;负责处理存在该directive的元素以及其下的所有子元素。
语句&lt;code&gt;InvoiceController as invoice&lt;/code&gt;告诉Angular实例化该controller并且用变量&lt;code&gt;invoice&lt;/code&gt;来存储到当前的scope中。
于是可以在template里通过invoice来调用controller的变量和方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-databinding2.png&#34; alt=&#34;concepts-databinding2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;service-与视图无关的业务逻辑&#34;&gt;service：与视图无关的业务逻辑&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/bJ7Ci5uRFycAnuup7n9I/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上一个例子中，&lt;code&gt;controller&lt;/code&gt;包含了所有的逻辑。然而当我们的应用不断增长壮大之后，一个良好的实践是将与视图无关的业务逻辑
抽离到&lt;code&gt;service&lt;/code&gt;中去，这使得这些方法可以被应用的其他部分进行复用。
我们将&lt;code&gt;convertCurrency&lt;/code&gt;和相关的定义移到了service中，但是controller是怎样获取并使用到一个已经分离出去的方法的呢？&lt;/p&gt;

&lt;p&gt;这就是&lt;code&gt;Dependency Injection&lt;/code&gt;发挥作用的地方了。
DI是一种软件设计模式，用来处理对象和方法的创建以及确保它们得到它们的依赖。
Angular中的一切（directives,filters,controllers,services,&amp;hellip;）都是通过DI创建并且管理的。
在Angular里，DI的容器称之为&lt;code&gt;Injector&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-module-injector.png&#34; alt=&#34;concepts-module-injector&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了使用DI，需要有一个地方使得所有事物一起工作并且注册，这就是在Angular中使用&lt;code&gt;modules&lt;/code&gt;的目的。
当Angular启动时，它会使用具有&lt;code&gt;ng-app&lt;/code&gt;这一directive定义的名称的module的配置，
同时包含了该module所依赖的所有modules的配置。&lt;/p&gt;

&lt;p&gt;在上述的例子中，这个template包含了directive &lt;code&gt;ng-app=&amp;quot;invoice2&amp;quot;&lt;/code&gt;。这告诉Angular使用&lt;code&gt;invoice2&lt;/code&gt;
module作为本应用的主module。&lt;code&gt;angular.module(&amp;quot;invoice2&amp;quot;,[&amp;quot;finance2&amp;quot;])&lt;/code&gt;表明了&lt;code&gt;invoice2&lt;/code&gt;module依赖于
&lt;code&gt;finance2&lt;/code&gt;模块，通过这个，Angular使用&lt;code&gt;InvoiceController&lt;/code&gt;以及&lt;code&gt;currencyConverter&lt;/code&gt;服务。&lt;/p&gt;

&lt;p&gt;现在Angular知道了应用的所有部分，需要去创建它们。在前面我们知道controllers通过构造方法来创建。
至于services，有很多种方法来指定它们的创建方式，在上述的例子中，我们使用&lt;code&gt;factory&lt;/code&gt;来创建&lt;code&gt;currencyConverter&lt;/code&gt;，
此函数应该要返回currencyConverter service实例。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里牵扯到 factory和service的区别，factory最终需要显式返回一个实例，而service会以构造函数的形式创建服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-module-service.png&#34; alt=&#34;concepts-module-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回到最初的问题，InvoiceController是怎样获得currencyConverter的引用的？
在Angular中，通过简单的在构造方法中定义arguments就可以做到。通过这种方式，&lt;code&gt;injector&lt;/code&gt;就能够以正确的顺序
创建对象，并且将先前创建的对象传递到依赖于它们的对象的工厂中。在上述的例子中，InvoiceController有一个argument叫做
currencyConverter，通过这个，Angular就知道了controller和service之间的依赖关系，并且通过该service的实例来调用controller的构造函数进行实例化。&lt;/p&gt;

&lt;p&gt;至于我们在module.controller中传递了一个数组，是为了使得代码在经过压缩和uglify之后仍然能够正常工作的机制，因为这样arguments可能会被&lt;code&gt;a&lt;/code&gt;这样的变量名替代。&lt;/p&gt;

&lt;h3 id=&#34;data-binding&#34;&gt;Data Binding&lt;/h3&gt;

&lt;p&gt;数据绑定在传统的模板系统中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/One_Way_Data_Binding.png&#34; alt=&#34;One_Way_Data_Binding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数据绑定在Angular模板系统中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/Two_Way_Data_Binding.png&#34; alt=&#34;Two_Way_Data_Binding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但也因此要特别注意不要造成死循环&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
