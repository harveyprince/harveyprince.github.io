<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.17" />
  <meta name="author" content="Jason">
  <meta name="description" content="Student">

  <link rel="stylesheet" href="/blog/css/highlight.min.css">
  <link rel="stylesheet" href="/blog/css/bootstrap.min.css">
  <link rel="stylesheet" href="/blog/css/font-awesome.min.css">
  <link rel="stylesheet" href="/blog/css/academicons.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700|Merriweather|Roboto+Mono">
  <link rel="stylesheet" href="/blog/css/hugo-academic.css">
  

  <link rel="alternate" href="http://harveyprince.github.io/blog/index.xml" type="application/rss+xml" title="Jason Lab">
  <link rel="feed" href="http://harveyprince.github.io/blog/index.xml" type="application/rss+xml" title="Jason Lab">

  <link rel="shortcut icon" href="/blog/img/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="http://harveyprince.github.io/blog/post/AngularjsSourceCodeInjector/">

  

  <title>Angular1 Source Code Injector | Jason Lab</title>

</head>
<body id="top">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/blog/">Jason Lab</a>
    </div>

    
    <div class="collapse navbar-collapse" id="#navbar-collapse-1">

      
      <ul class="nav navbar-nav navbar-right">
        
        <li class="nav-item"><a href="/blog/#top">Home</a></li>
        
        <li class="nav-item"><a href="/blog/#posts">Posts</a></li>
        
        <li class="nav-item"><a href="/blog/#projects">Projects</a></li>
        
        <li class="nav-item"><a href="/blog/#contact">Contact</a></li>
        
      </ul>

    </div>
  </div>
</nav>

<div class="container">

  <article class="article" itemscope itemtype="http://schema.org/Article">

    

    <h1 itemprop="name">Angular1 Source Code Injector</h1>

    

<div class="article-metadata">

  <span class="article-date">
    <time datetime="2016-12-26 20:30:26 &#43;0800 CST" itemprop="datePublished">
      Mon, Dec 26, 2016
    </time>
  </span>

  
  
  
  <span class="article-tags">
    <i class="fa fa-tags"></i>
    
    <a class="article-tag-link" href="http://harveyprince.github.io/blog/tags/analyze">analyze</a
    >, 
    
    <a class="article-tag-link" href="http://harveyprince.github.io/blog/tags/source-code">source code</a
    >, 
    
    <a class="article-tag-link" href="http://harveyprince.github.io/blog/tags/angularjs">AngularJS</a
    >
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=http%3a%2f%2fharveyprince.github.io%2fblog%2fpost%2fAngularjsSourceCodeInjector%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Angular1%20Source%20Code%20Injector&amp;url=http%3a%2f%2fharveyprince.github.io%2fblog%2fpost%2fAngularjsSourceCodeInjector%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fharveyprince.github.io%2fblog%2fpost%2fAngularjsSourceCodeInjector%2f&amp;title=Angular1%20Source%20Code%20Injector"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=http%3a%2f%2fharveyprince.github.io%2fblog%2fpost%2fAngularjsSourceCodeInjector%2f&amp;title=Angular1%20Source%20Code%20Injector"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Angular1%20Source%20Code%20Injector&amp;body=http%3a%2f%2fharveyprince.github.io%2fblog%2fpost%2fAngularjsSourceCodeInjector%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>


    <div class="article-style" itemprop="articleBody">
      <p>基于版本：1.6.0</p>

<h2 id="injector">Injector</h2>

<hr />

<p>从整体的概念解读中，我们可以看出，AngularJS中很重要的一个依赖处理的概念就是Injector。
它很好地完成了所有依赖的管理，让我们从繁琐的对象创建工作中脱离出来，更关注功能实现。
从angularFiles.js可以看出Injector定义在<code>'src/auto/injector.js'</code>中。
</p>

<h2 id="injector是怎么工作的">Injector是怎么工作的</h2>

<hr />

<p>在这里不得不提一下js中一个方法——<code>toString()</code>，显而易见，这是一个将对象自身转化为字符串的函数，
在js里，<code>function</code>也可以这么做，举一个简单的例子</p>

<p><embed width="100%" height="500" src="https://embed.plnkr.co/M9gqs6cV6AYEAPjfA3WN/" /></p>

<p>function通过toString可以将自己的定义完全转换成字符串，这样子就可以提取其中的参数名了。</p>

<p>这里正则表达式派上了用场，看看injector.js中的函数定义</p>

<pre><code>    var ARROW_ARG = /^([^(]+?)=&gt;/;
    var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function stringifyFn(fn) {
      // Support: Chrome 50-51 only
      // Creating a new string by adding `' '` at the end, to hack around some bug in Chrome v50/51
      // (See https://github.com/angular/angular.js/issues/14487.)
      // TODO (gkalpak): Remove workaround when Chrome v52 is released
      return Function.prototype.toString.call(fn) + ' ';
    }
    
    function extractArgs(fn) {
      var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
          args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
      return args;
    }

</code></pre>

<blockquote>
<p>这里提到的Chrome v50/51 bug是针对arrow形式的函数<code>(arg0,arg1)=&gt;{}</code>调用toString产生的问题的，新的chrome版本已经解决，不深究</p>
</blockquote>

<p>我们来测试一下上面的函数</p>

<p><embed width="100%" height="500" src="https://embed.plnkr.co/mTTVnTwX8298ciXZCjoS/" /></p>

<p>可以看到，所需的参数都得到了初步的提取，通过split就能拿到一个arguments的array</p>

<h2 id="inject">$inject</h2>

<hr />

<p>其实我们可以直接通过给<code>function</code>增加<code>$inject</code>来声明其中的依赖，例如</p>

<pre><code>    function SomeCtrl ($scope) {
    
    }
    //方式1
    SomeCtrl.$inject = ['$scope'];
    angular
        .module('app', [])
        .controller('SomeCtrl', SomeCtrl);
      
    //方式2
    angular
        .module('app', [])
        .controller('SomeCtrl', SomeCtrl);
        
    //方式3
    angular
        .module('app', [])
        .controller('SomeCtrl', ['$scope',SomeCtrl]);
          
</code></pre>

<p>相比通过转化为字符串提取出arguments，方式1可以节省Angular很多的工作，
我们来看看Angular是如何导出<code>$inject</code>的就明白是怎么回事了</p>

<pre><code>    function annotate(fn, strictDi, name) {
      var $inject,
          argDecl,
          last;
    
      if (typeof fn === 'function') {
        if (!($inject = fn.$inject)) {
          $inject = [];
          if (fn.length) {
            if (strictDi) {
              if (!isString(name) || !name) {
                name = fn.name || anonFn(fn);
              }
              throw $injectorMinErr('strictdi',
                '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
            }
            argDecl = extractArgs(fn);
            forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
              arg.replace(FN_ARG, function(all, underscore, name) {//此处为了去处空格等字符
                $inject.push(name);
              });
            });
          }
          fn.$inject = $inject;//缓存起来，防止重复进行耗时的操作
        }
      } else if (isArray(fn)) {
        last = fn.length - 1;
        assertArgFn(fn[last], 'fn');
        $inject = fn.slice(0, last);
      } else {
        assertArgFn(fn, 'fn', true);
      }
      return $inject;
    }

</code></pre>

<p>可以看出，非array并且不声明<code>$inject</code>的function在解析上会有一定的性能消耗，
并且Angular也意识到了这一点，尽量避免重复这项操作</p>

<h2 id="再来看看injector">再来看看Injector</h2>

<hr />

<p>在injector.js中，实现了一个createInjector的方法来封装injector</p>

<pre><code>    function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
          providerSuffix = 'Provider',
          path = [],
          loadedModules = new HashMap([], true),
          providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }
          },
          providerInjector = (providerCache.$injector =
              createInternalInjector(providerCache, function(serviceName, caller) {
                if (angular.isString(caller)) {
                  path.push(caller);
                }
                throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' &lt;- '));
              })),
          instanceCache = {},
          protoInstanceInjector =
              createInternalInjector(instanceCache, function(serviceName, caller) {
                var provider = providerInjector.get(serviceName + providerSuffix, caller);
                return instanceInjector.invoke(
                    provider.$get, provider, undefined, serviceName);
              }),
          instanceInjector = protoInstanceInjector;
        
        providerCache['$injector' + providerSuffix] = { $get: valueFn(protoInstanceInjector) };
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) { if (fn) instanceInjector.invoke(fn); });
        
        return instanceInjector;
        //省略函数定义
        
    }

</code></pre>

<p>我们看看<code>providerCache</code>，其中形如<code>provider: supportObject(provider)</code>，后一个provider是后边定义的<code>function provider(name, provider_) {...}</code>，</p>

<pre><code>    function supportObject(delegate) {
        return function(key, value) {
          if (isObject(key)) {
            forEach(key, reverseParams(delegate));
          } else {
            return delegate(key, value);
          }
        };
      }
</code></pre>

<p>这里当key不为object时进行正常调用，为object时进行了一个处理，但是这一处理目前我还没遇到过适用场景。</p>

<p>不过看得出来，这里有一个很重要的概念<code>provider</code>。</p>

<p>Angular中需要对象协作来完成任务，这些对象是通过<code>injector service</code>初始化创建并协同工作的。
injector创建了两种类型的对象，<code>services</code>和<code>specialized objects</code>。
service是由编写该service的开发人员定义api的对象，
Specialized objects是符合特定Angular框架api的对象，这些对象是controllers, directives, filters 或者 animations。
injector需要知道如何创建这些对象，我们是通过注册一个recipe来使用injector创建对象的，目前有五种recipe类型。
其中最重要的是Provider recipe，其他的Value, Factory, Service 和 Constant仅仅是provider的语法糖。</p>

<h2 id="简单认识一下这些recipe">简单认识一下这些recipe</h2>

<hr />

<h3 id="value-recipe">Value recipe</h3>

<p>有时候我们需要一个很简单的提供基本数值的服务</p>

<pre><code>    var myApp = angular.module('myApp', []);
    myApp.value('clientId', 'a12345654321x');
    //最终可以通过依赖注入的形式获取到这个值
    myApp.controller('DemoController', ['clientId', function DemoController(clientId) {
      this.clientId = clientId;
    }]);
</code></pre>

<p>关于value的函数定义</p>

<pre><code>    function value(name, val) { return factory(name, valueFn(val), false); }
    //其中
    function valueFn(value) {return function valueRef() {return value;};}

</code></pre>

<h3 id="factory-recipe">Factory recipe</h3>

<p>value过于简单，有时候我们需要复杂一点的功能来为我们提供服务，factory可以做到</p>

<ul>
<li>可以使用其他services（拥有依赖）</li>
<li>service初始化</li>
<li>延迟／懒 初始化</li>
</ul>

<blockquote>
<p>注意一点，Angular中所有的service都是单例</p>
</blockquote>

<pre><code>    myApp.factory('clientId', function clientIdFactory() {
      return 'a12345654321x';
    });
    //进一步可以
    myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) {
      var encrypt = function(data1, data2) {
        // NSA-proof encryption algorithm:
        return (data1 + ':' + data2).toUpperCase();
      };
    
      var secret = window.localStorage.getItem('myApp.secret');
      var apiToken = encrypt(clientId, secret);
    
      return apiToken;
    }]);
</code></pre>

<p>关于factory的函数定义</p>

<pre><code>    function factory(name, factoryFn, enforce) {
        return provider(name, {
          $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
        });
      }

</code></pre>

<h3 id="service-recipe">Service recipe</h3>

<p>Javascript开发者通常会使用现有的类型来进行面向对象编程，我们可以通过以下两种方式来实现面向对象</p>

<pre><code>    function UnicornLauncher(apiToken) {
    
      this.launchedCount = 0;
      this.launch = function() {
        // Make a request to the remote API and include the apiToken
        ...
        this.launchedCount++;
      }
    }
    //方式一
    myApp.factory('unicornLauncher', [&quot;apiToken&quot;, function(apiToken) {
      return new UnicornLauncher(apiToken);
    }]);
    //方式二
    myApp.service('unicornLauncher', [&quot;apiToken&quot;, UnicornLauncher]);
</code></pre>

<p>关于service的函数定义</p>

<pre><code>    function service(name, constructor) {
        return factory(name, ['$injector', function($injector) {
          return $injector.instantiate(constructor);
        }]);
      }
</code></pre>

<h3 id="provider-recipe">Provider recipe</h3>

<p>正如之前所提到过的，provider recipe是最核心的recipe，它能实现最全面的功能，但是对于大多数service来说功能上有点过了。
provider recipe实现了一个$get方法，这个方法是一个工厂方法，正如我们在使用factory recipe时一样，而事实上，当我们在定义
一个factory recipe的时候，一个拥有$get方法的空的provider类型被创建了。</p>

<p>仅仅当你想要在应用程序启动之前进行配置并对应用程序提供api时，才应该使用provider recipe。</p>

<pre><code>    myApp.provider('unicornLauncher', function UnicornLauncherProvider() {
      var useTinfoilShielding = false;
    
      this.useTinfoilShielding = function(value) {
        useTinfoilShielding = !!value;
      };
    
      this.$get = [&quot;apiToken&quot;, function unicornLauncherFactory(apiToken) {
    
        // let's assume that the UnicornLauncher constructor was also changed to
        // accept and use the useTinfoilShielding argument
        return new UnicornLauncher(apiToken, useTinfoilShielding);
      }];
    });
    //在配置阶段
    myApp.config([&quot;unicornLauncherProvider&quot;, function(unicornLauncherProvider) {
      unicornLauncherProvider.useTinfoilShielding(true);
    }]);
</code></pre>

<p>关于provider的函数定义</p>

<pre><code>    function provider(name, provider_) {
        assertNotHasOwnProperty(name, 'service');
        if (isFunction(provider_) || isArray(provider_)) {
          provider_ = providerInjector.instantiate(provider_);
        }
        if (!provider_.$get) {
          throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
        }
        return (providerCache[name + providerSuffix] = provider_);
      }

</code></pre>

<h3 id="constant-recipe">Constant recipe</h3>

<p>Angular的生命周期包含配置阶段和运行阶段，在配置阶段的时候没有service是available的，
所以无法在配置阶段引入任何一个service，甚至是简单的value recipe也不行。
然而仍然有一些需要在这个时期使用的，比如url的前缀等等一系列不需要依赖的常量。
这个时候我们就可以使用constant，他和value的区别就是constant还可以在配置阶段使用。</p>

<pre><code>    myApp.constant('planetName', 'Greasy Giant');
    //配置阶段
    myApp.config(['unicornLauncherProvider', 'planetName', function(unicornLauncherProvider, planetName) {
      unicornLauncherProvider.useTinfoilShielding(true);
      unicornLauncherProvider.stampText(planetName);
    }]);
    //运行阶段
    myApp.controller('DemoController', [&quot;clientId&quot;, &quot;planetName&quot;, function DemoController(clientId, planetName) {
      this.clientId = clientId;
      this.planetName = planetName;
    }]);
</code></pre>

<p>关于constant的函数定义</p>

<pre><code>    function constant(name, value) {
        assertNotHasOwnProperty(name, 'constant');
        providerCache[name] = value;
        instanceCache[name] = value;
      }
</code></pre>

<p>可以看出，constant在调用之后立马加入了缓存中。</p>

<h3 id="special-purpose-objects">Special Purpose Objects</h3>

<p>前面我们提到过还有一些有别于services的Specialized objects，这些对象以插件的形式扩展框架，因此必须实现Angular框架声明的接口。
这些接口就是Controller, Directive, Filter 和 Animation。
injector在创建这些对象（除了Controller）的时候，使用了Factory的形式，即需要显式地返回一个对象。
而Controller使用了构造器的形式。</p>

<h2 id="回到createinjector">回到createInjector</h2>

<hr />

<p>通过分析可以知道providerCache的结构</p>

<pre><code>    {
        $provide: {
            provider: func,
            factory: func,
            service: func,
            value: func,
            constant: func,
            decorator: func
        },
        $injector: obj,
        $injectorProvider: obj
        //还有用户定义的所有provider，都以name+'Provider'为key缓存起来了
        //还有用户定义的constant，都以name为key缓存
    }

</code></pre>

<p>createInjector最终返回了一个instanceInjector</p>

<pre><code>    providerInjector = (providerCache.$injector =
              createInternalInjector(providerCache, function(serviceName, caller) {
                if (angular.isString(caller)) {
                  path.push(caller);
                }
                throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' &lt;- '));
              })),
    instanceCache = {},
    protoInstanceInjector =
              createInternalInjector(instanceCache, function(serviceName, caller) {
                var provider = providerInjector.get(serviceName + providerSuffix, caller);
                return instanceInjector.invoke(
                    provider.$get, provider, undefined, serviceName);
              }),
    instanceInjector = protoInstanceInjector;
</code></pre>

<p>关于createInternalInjector的定义</p>

<pre><code>    function createInternalInjector(cache, factory) {
        //省略函数定义
        return {
          invoke: invoke,
          instantiate: instantiate,
          get: getService,
          annotate: createInjector.$$annotate,
          has: function(name) {
            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
          }
        };
      }
    createInjector.$$annotate = annotate;
</code></pre>

<p>传入的cache和factory主要用在了getService里</p>

<pre><code>    function getService(serviceName, caller) {
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr('cdep', 'Circular dependency found: {0}',
                    serviceName + ' &lt;- ' + path.join(' &lt;- '));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          cache[serviceName] = factory(serviceName, caller);
          return cache[serviceName];
        } catch (err) {
          if (cache[serviceName] === INSTANTIATING) {
            delete cache[serviceName];
          }
          throw err;
        } finally {
          path.shift();
        }
      }
    }
</code></pre>

<p>从cache中获取service，并且检测依赖的回环和provider不存在的情况。</p>

<p>从constant recipe可以知道，instanceCache里目前只缓存了constant。
protoInstanceInjector在调用get时，先从instanceCache检测，不存在定义时
通过providerInjector来从providerCache里拿相应的provider。
在获取provider之后调用了invoke方法</p>

<pre><code>    return instanceInjector.invoke(
                    provider.$get, provider, undefined, serviceName);
</code></pre>

<p>来看一下invoke的定义</p>

<pre><code>    function injectionArgs(fn, locals, serviceName) {
      var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName);

      for (var i = 0, length = $inject.length; i &lt; length; i++) {
        var key = $inject[i];
        if (typeof key !== 'string') {
          throw $injectorMinErr('itkn',
                  'Incorrect injection token! Expected service name as string, got {0}', key);
        }
        //这里最终返回的args是$inject对应的provider对象的列表
        args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? locals[key] :
                                                         getService(key, serviceName));
      }
      return args;
    }
    function invoke(fn, self, locals, serviceName) {
      if (typeof locals === 'string') {
        serviceName = locals;
        locals = null;
      }

      var args = injectionArgs(fn, locals, serviceName);
      if (isArray(fn)) {
        fn = fn[fn.length - 1];
      }

      if (!isClass(fn)) {
        // http://jsperf.com/angularjs-invoke-apply-vs-switch
        // #5388
        return fn.apply(self, args);
      } else {
        args.unshift(null);
        //这里有一点绕，args中unshift一个null是用于占thisArg的位，由于new操作符，该参数无效
        //以下相当于以fn为构造函数进行new操作，并将不带null的args spread开作为参数传递
        //在instantiate中也有类似的方式
        return new (Function.prototype.bind.apply(fn, args))();
      }
    }
</code></pre>

<p>所以可以看出，invoke将会得到一个切实可用的service，并在获取的过程中进行了缓存以及将所有的需求的依赖进行注入。</p>

<p>整理一下流程就是，instanceInjector通过调用get，可以从instanceCache中获取已经初始化的service，如果instanceCache中没有，
就从providerCache中获取其provider定义，然后初始化再缓存至instanceCache中，并返回初始化好的service。</p>

<h2 id="再回到createinjector">再回到createInjector</h2>

<hr />

<p>现在，我们已经弄清楚了injector的工作原理了，在返回instanceInjector之前，还调用了一句</p>

<pre><code>    var runBlocks = loadModules(modulesToLoad);
    //省略
    forEach(runBlocks, function(fn) { if (fn) instanceInjector.invoke(fn); });
</code></pre>

<p>显而易见这是将所有需要加载的module进行了invoke，我们来看看loadModules的定义</p>

<pre><code>    function loadModules(modulesToLoad) {
        assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
        var runBlocks = [], moduleFn;
        forEach(modulesToLoad, function(module) {
          //如果模块已经加载，直接返回
          if (loadedModules.get(module)) return;
          //没有加载时，设置为已加载，并继续执行
          loadedModules.put(module, true);
          //执行invoke队列的函数声明
          function runInvokeQueue(queue) {
            var i, ii;
            for (i = 0, ii = queue.length; i &lt; ii; i++) {
              var invokeArgs = queue[i],
                  provider = providerInjector.get(invokeArgs[0]);
    
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          }
    
          try {
            if (isString(module)) {
              moduleFn = angularModule(module);
              runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
              //执行invoke队列
              runInvokeQueue(moduleFn._invokeQueue);
              runInvokeQueue(moduleFn._configBlocks);
            } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
            } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
            } else {
              assertArgFn(module, 'module');
            }
          } catch (e) {
            if (isArray(module)) {
              module = module[module.length - 1];
            }
            if (e.message &amp;&amp; e.stack &amp;&amp; e.stack.indexOf(e.message) === -1) {
              // Safari &amp; FF's stack traces don't contain error.message content
              // unlike those of Chrome and IE
              // So if stack doesn't contain message, we create a new string that contains both.
              // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
              // eslint-disable-next-line no-ex-assign
              e = e.message + '\n' + e.stack;
            }
            throw $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}',
                      module, e.stack || e.message || e);
          }
        });
        return runBlocks;
      }

</code></pre>

<p>可以看出，涉及到了很多angularModule方面的概念，其相关定义都在loader.js中，在module相关章节展开时再做解读，
包括modulesToLoad的格式，module的invoke。</p>
    </div>

  </article>

  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/"><span
      aria-hidden="true">&larr;</span> Angular1 Source Code Overview</a></li>
    

    
  </ul>
</nav>

  
<section id="comments">
  <div id="disqus_thread">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'harveyprince';
    var disqus_identifier = 'http:\/\/harveyprince.github.io\/blog\/post\/AngularjsSourceCodeInjector\/';
    var disqus_title = 'Angular1 Source Code Injector';
    var disqus_url = 'http:\/\/harveyprince.github.io\/blog\/post\/AngularjsSourceCodeInjector\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</section>



</div>
<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2016 Jason &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.4/TweenMax.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/ScrollToPlugin.min.js"></script>
    <script src="/blog/js/jquery-1.12.3.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script src="/blog/js/hugo-academic.js"></script>
    

    

    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    

  </body>
</html>

