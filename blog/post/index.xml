<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Jason Lab</title>
    <link>http://harveyprince.github.io/blog/post/index.xml</link>
    <description>Recent content in Post-rsses on Jason Lab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Jason</copyright>
    <lastBuildDate>Mon, 26 Dec 2016 20:30:26 +0800</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Angular1 Source Code Injector</title>
      <link>http://harveyprince.github.io/blog/post/AngularjsSourceCodeInjector/</link>
      <pubDate>Mon, 26 Dec 2016 20:30:26 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/AngularjsSourceCodeInjector/</guid>
      <description>&lt;p&gt;基于版本：1.6.0&lt;/p&gt;

&lt;h2 id=&#34;injector&#34;&gt;Injector&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;从整体的概念解读中，我们可以看出，AngularJS中很重要的一个依赖处理的概念就是Injector。
它很好地完成了所有依赖的管理，让我们从繁琐的对象创建工作中脱离出来，更关注功能实现。
从angularFiles.js可以看出Injector定义在&lt;code&gt;&#39;src/auto/injector.js&#39;&lt;/code&gt;中。
&lt;/p&gt;

&lt;h2 id=&#34;injector是怎么工作的&#34;&gt;Injector是怎么工作的&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在这里不得不提一下js中一个方法——&lt;code&gt;toString()&lt;/code&gt;，显而易见，这是一个将对象自身转化为字符串的函数，
在js里，&lt;code&gt;function&lt;/code&gt;也可以这么做，举一个简单的例子&lt;/p&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/M9gqs6cV6AYEAPjfA3WN/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;function通过toString可以将自己的定义完全转换成字符串，这样子就可以提取其中的参数名了。&lt;/p&gt;

&lt;p&gt;这里正则表达式派上了用场，看看injector.js中的函数定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var ARROW_ARG = /^([^(]+?)=&amp;gt;/;
    var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function stringifyFn(fn) {
      // Support: Chrome 50-51 only
      // Creating a new string by adding `&#39; &#39;` at the end, to hack around some bug in Chrome v50/51
      // (See https://github.com/angular/angular.js/issues/14487.)
      // TODO (gkalpak): Remove workaround when Chrome v52 is released
      return Function.prototype.toString.call(fn) + &#39; &#39;;
    }
    
    function extractArgs(fn) {
      var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, &#39;&#39;),
          args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
      return args;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里提到的Chrome v50/51 bug是针对arrow形式的函数&lt;code&gt;(arg0,arg1)=&amp;gt;{}&lt;/code&gt;调用toString产生的问题的，新的chrome版本已经解决，不深究&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们来测试一下上面的函数&lt;/p&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/mTTVnTwX8298ciXZCjoS/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，所需的参数都得到了初步的提取，通过split就能拿到一个arguments的array&lt;/p&gt;

&lt;h2 id=&#34;inject&#34;&gt;$inject&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;其实我们可以直接通过给&lt;code&gt;function&lt;/code&gt;增加&lt;code&gt;$inject&lt;/code&gt;来声明其中的依赖，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function SomeCtrl ($scope) {
    
    }
    //方式1
    SomeCtrl.$inject = [&#39;$scope&#39;];
    angular
        .module(&#39;app&#39;, [])
        .controller(&#39;SomeCtrl&#39;, SomeCtrl);
      
    //方式2
    angular
        .module(&#39;app&#39;, [])
        .controller(&#39;SomeCtrl&#39;, SomeCtrl);
        
    //方式3
    angular
        .module(&#39;app&#39;, [])
        .controller(&#39;SomeCtrl&#39;, [&#39;$scope&#39;,SomeCtrl]);
          
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相比通过转化为字符串提取出arguments，方式1可以节省Angular很多的工作，
我们来看看Angular是如何导出&lt;code&gt;$inject&lt;/code&gt;的就明白是怎么回事了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function annotate(fn, strictDi, name) {
      var $inject,
          argDecl,
          last;
    
      if (typeof fn === &#39;function&#39;) {
        if (!($inject = fn.$inject)) {
          $inject = [];
          if (fn.length) {
            if (strictDi) {
              if (!isString(name) || !name) {
                name = fn.name || anonFn(fn);
              }
              throw $injectorMinErr(&#39;strictdi&#39;,
                &#39;{0} is not using explicit annotation and cannot be invoked in strict mode&#39;, name);
            }
            argDecl = extractArgs(fn);
            forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
              arg.replace(FN_ARG, function(all, underscore, name) {//此处为了去处空格等字符
                $inject.push(name);
              });
            });
          }
          fn.$inject = $inject;//缓存起来，防止重复进行耗时的操作
        }
      } else if (isArray(fn)) {
        last = fn.length - 1;
        assertArgFn(fn[last], &#39;fn&#39;);
        $inject = fn.slice(0, last);
      } else {
        assertArgFn(fn, &#39;fn&#39;, true);
      }
      return $inject;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，非array并且不声明&lt;code&gt;$inject&lt;/code&gt;的function在解析上会有一定的性能消耗，
并且Angular也意识到了这一点，尽量避免重复这项操作&lt;/p&gt;

&lt;h2 id=&#34;再来看看injector&#34;&gt;再来看看Injector&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在injector.js中，实现了一个createInjector的方法来封装injector&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
          providerSuffix = &#39;Provider&#39;,
          path = [],
          loadedModules = new HashMap([], true),
          providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }
          },
          providerInjector = (providerCache.$injector =
              createInternalInjector(providerCache, function(serviceName, caller) {
                if (angular.isString(caller)) {
                  path.push(caller);
                }
                throw $injectorMinErr(&#39;unpr&#39;, &#39;Unknown provider: {0}&#39;, path.join(&#39; &amp;lt;- &#39;));
              })),
          instanceCache = {},
          protoInstanceInjector =
              createInternalInjector(instanceCache, function(serviceName, caller) {
                var provider = providerInjector.get(serviceName + providerSuffix, caller);
                return instanceInjector.invoke(
                    provider.$get, provider, undefined, serviceName);
              }),
          instanceInjector = protoInstanceInjector;
        
        providerCache[&#39;$injector&#39; + providerSuffix] = { $get: valueFn(protoInstanceInjector) };
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get(&#39;$injector&#39;);
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) { if (fn) instanceInjector.invoke(fn); });
        
        return instanceInjector;
        //省略函数定义
        
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看看&lt;code&gt;providerCache&lt;/code&gt;，其中形如&lt;code&gt;provider: supportObject(provider)&lt;/code&gt;，后一个provider是后边定义的&lt;code&gt;function provider(name, provider_) {...}&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function supportObject(delegate) {
        return function(key, value) {
          if (isObject(key)) {
            forEach(key, reverseParams(delegate));
          } else {
            return delegate(key, value);
          }
        };
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里当key不为object时进行正常调用，为object时进行了一个处理，但是这一处理目前我还没遇到过适用场景。&lt;/p&gt;

&lt;p&gt;不过看得出来，这里有一个很重要的概念&lt;code&gt;provider&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Angular中需要对象协作来完成任务，这些对象是通过&lt;code&gt;injector service&lt;/code&gt;初始化创建并协同工作的。
injector创建了两种类型的对象，&lt;code&gt;services&lt;/code&gt;和&lt;code&gt;specialized objects&lt;/code&gt;。
service是由编写该service的开发人员定义api的对象，
Specialized objects是符合特定Angular框架api的对象，这些对象是&lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;directives&lt;/code&gt;, &lt;code&gt;filters&lt;/code&gt; 或者 &lt;code&gt;animations&lt;/code&gt;。
injector需要知道如何创建这些对象，我们是通过注册一个recipe来使用injector创建对象的，目前有五种recipe类型。
其中最重要的是&lt;code&gt;Provider recipe&lt;/code&gt;，其他的Value, Factory, Service 和 Constant仅仅是provider的语法糖。&lt;/p&gt;

&lt;h2 id=&#34;简单认识一下这些recipe&#34;&gt;简单认识一下这些recipe&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;value-recipe&#34;&gt;Value recipe&lt;/h3&gt;

&lt;p&gt;有时候我们需要一个很简单的提供基本数值的服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var myApp = angular.module(&#39;myApp&#39;, []);
    myApp.value(&#39;clientId&#39;, &#39;a12345654321x&#39;);
    //最终可以通过依赖注入的形式获取到这个值
    myApp.controller(&#39;DemoController&#39;, [&#39;clientId&#39;, function DemoController(clientId) {
      this.clientId = clientId;
    }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于value的函数定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function value(name, val) { return factory(name, valueFn(val), false); }
    //其中
    function valueFn(value) {return function valueRef() {return value;};}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;factory-recipe&#34;&gt;Factory recipe&lt;/h3&gt;

&lt;p&gt;value过于简单，有时候我们需要复杂一点的功能来为我们提供服务，factory可以做到&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以使用其他services（拥有依赖）&lt;/li&gt;
&lt;li&gt;service初始化&lt;/li&gt;
&lt;li&gt;延迟／懒 初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注意一点，Angular中所有的service都是单例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    myApp.factory(&#39;clientId&#39;, function clientIdFactory() {
      return &#39;a12345654321x&#39;;
    });
    //进一步可以
    myApp.factory(&#39;apiToken&#39;, [&#39;clientId&#39;, function apiTokenFactory(clientId) {
      var encrypt = function(data1, data2) {
        // NSA-proof encryption algorithm:
        return (data1 + &#39;:&#39; + data2).toUpperCase();
      };
    
      var secret = window.localStorage.getItem(&#39;myApp.secret&#39;);
      var apiToken = encrypt(clientId, secret);
    
      return apiToken;
    }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于factory的函数定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function factory(name, factoryFn, enforce) {
        return provider(name, {
          $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
        });
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;service-recipe&#34;&gt;Service recipe&lt;/h3&gt;

&lt;p&gt;Javascript开发者通常会使用现有的类型来进行面向对象编程，我们可以通过以下两种方式来实现面向对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function UnicornLauncher(apiToken) {
    
      this.launchedCount = 0;
      this.launch = function() {
        // Make a request to the remote API and include the apiToken
        ...
        this.launchedCount++;
      }
    }
    //方式一
    myApp.factory(&#39;unicornLauncher&#39;, [&amp;quot;apiToken&amp;quot;, function(apiToken) {
      return new UnicornLauncher(apiToken);
    }]);
    //方式二
    myApp.service(&#39;unicornLauncher&#39;, [&amp;quot;apiToken&amp;quot;, UnicornLauncher]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于service的函数定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function service(name, constructor) {
        return factory(name, [&#39;$injector&#39;, function($injector) {
          return $injector.instantiate(constructor);
        }]);
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;provider-recipe&#34;&gt;Provider recipe&lt;/h3&gt;

&lt;p&gt;正如之前所提到过的，&lt;code&gt;provider recipe&lt;/code&gt;是最核心的recipe，它能实现最全面的功能，但是对于大多数service来说功能上有点过了。
&lt;code&gt;provider recipe&lt;/code&gt;实现了一个$get方法，这个方法是一个工厂方法，正如我们在使用factory recipe时一样，而事实上，当我们在定义
一个factory recipe的时候，一个拥有$get方法的空的provider类型被创建了。&lt;/p&gt;

&lt;p&gt;仅仅当你想要在应用程序启动之前进行配置并对应用程序提供api时，才应该使用provider recipe。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    myApp.provider(&#39;unicornLauncher&#39;, function UnicornLauncherProvider() {
      var useTinfoilShielding = false;
    
      this.useTinfoilShielding = function(value) {
        useTinfoilShielding = !!value;
      };
    
      this.$get = [&amp;quot;apiToken&amp;quot;, function unicornLauncherFactory(apiToken) {
    
        // let&#39;s assume that the UnicornLauncher constructor was also changed to
        // accept and use the useTinfoilShielding argument
        return new UnicornLauncher(apiToken, useTinfoilShielding);
      }];
    });
    //在配置阶段
    myApp.config([&amp;quot;unicornLauncherProvider&amp;quot;, function(unicornLauncherProvider) {
      unicornLauncherProvider.useTinfoilShielding(true);
    }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于provider的函数定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function provider(name, provider_) {
        assertNotHasOwnProperty(name, &#39;service&#39;);
        if (isFunction(provider_) || isArray(provider_)) {
          provider_ = providerInjector.instantiate(provider_);
        }
        if (!provider_.$get) {
          throw $injectorMinErr(&#39;pget&#39;, &#39;Provider \&#39;{0}\&#39; must define $get factory method.&#39;, name);
        }
        return (providerCache[name + providerSuffix] = provider_);
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;constant-recipe&#34;&gt;Constant recipe&lt;/h3&gt;

&lt;p&gt;Angular的生命周期包含配置阶段和运行阶段，在配置阶段的时候没有service是available的，
所以无法在配置阶段引入任何一个service，甚至是简单的value recipe也不行。
然而仍然有一些需要在这个时期使用的，比如url的前缀等等一系列不需要依赖的常量。
这个时候我们就可以使用constant，他和value的区别就是constant还可以在配置阶段使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    myApp.constant(&#39;planetName&#39;, &#39;Greasy Giant&#39;);
    //配置阶段
    myApp.config([&#39;unicornLauncherProvider&#39;, &#39;planetName&#39;, function(unicornLauncherProvider, planetName) {
      unicornLauncherProvider.useTinfoilShielding(true);
      unicornLauncherProvider.stampText(planetName);
    }]);
    //运行阶段
    myApp.controller(&#39;DemoController&#39;, [&amp;quot;clientId&amp;quot;, &amp;quot;planetName&amp;quot;, function DemoController(clientId, planetName) {
      this.clientId = clientId;
      this.planetName = planetName;
    }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于constant的函数定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function constant(name, value) {
        assertNotHasOwnProperty(name, &#39;constant&#39;);
        providerCache[name] = value;
        instanceCache[name] = value;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，constant在调用之后立马加入了缓存中。&lt;/p&gt;

&lt;h3 id=&#34;special-purpose-objects&#34;&gt;Special Purpose Objects&lt;/h3&gt;

&lt;p&gt;前面我们提到过还有一些有别于services的Specialized objects，这些对象以插件的形式扩展框架，因此必须实现Angular框架声明的接口。
这些接口就是Controller, Directive, Filter 和 Animation。
injector在创建这些对象（除了Controller）的时候，使用了Factory的形式，即需要显式地返回一个对象。
而Controller使用了构造器的形式。&lt;/p&gt;

&lt;h2 id=&#34;回到createinjector&#34;&gt;回到createInjector&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;通过分析可以知道&lt;code&gt;providerCache&lt;/code&gt;的结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        $provide: {
            provider: func,
            factory: func,
            service: func,
            value: func,
            constant: func,
            decorator: func
        },
        $injector: obj,
        $injectorProvider: obj
        //还有用户定义的所有provider，都以name+&#39;Provider&#39;为key缓存起来了
        //还有用户定义的constant，都以name为key缓存
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createInjector&lt;/code&gt;最终返回了一个&lt;code&gt;instanceInjector&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    providerInjector = (providerCache.$injector =
              createInternalInjector(providerCache, function(serviceName, caller) {
                if (angular.isString(caller)) {
                  path.push(caller);
                }
                throw $injectorMinErr(&#39;unpr&#39;, &#39;Unknown provider: {0}&#39;, path.join(&#39; &amp;lt;- &#39;));
              })),
    instanceCache = {},
    protoInstanceInjector =
              createInternalInjector(instanceCache, function(serviceName, caller) {
                var provider = providerInjector.get(serviceName + providerSuffix, caller);
                return instanceInjector.invoke(
                    provider.$get, provider, undefined, serviceName);
              }),
    instanceInjector = protoInstanceInjector;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于&lt;code&gt;createInternalInjector&lt;/code&gt;的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function createInternalInjector(cache, factory) {
        //省略函数定义
        return {
          invoke: invoke,
          instantiate: instantiate,
          get: getService,
          annotate: createInjector.$$annotate,
          has: function(name) {
            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
          }
        };
      }
    createInjector.$$annotate = annotate;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入的&lt;code&gt;cache&lt;/code&gt;和&lt;code&gt;factory&lt;/code&gt;主要用在了&lt;code&gt;getService&lt;/code&gt;里&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function getService(serviceName, caller) {
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr(&#39;cdep&#39;, &#39;Circular dependency found: {0}&#39;,
                    serviceName + &#39; &amp;lt;- &#39; + path.join(&#39; &amp;lt;- &#39;));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          cache[serviceName] = factory(serviceName, caller);
          return cache[serviceName];
        } catch (err) {
          if (cache[serviceName] === INSTANTIATING) {
            delete cache[serviceName];
          }
          throw err;
        } finally {
          path.shift();
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从cache中获取service，并且检测依赖的回环和provider不存在的情况。&lt;/p&gt;

&lt;p&gt;从&lt;code&gt;constant recipe&lt;/code&gt;可以知道，&lt;code&gt;instanceCache&lt;/code&gt;里目前只缓存了constant。
&lt;code&gt;protoInstanceInjector&lt;/code&gt;在调用get时，先从&lt;code&gt;instanceCache&lt;/code&gt;检测，不存在定义时
通过&lt;code&gt;providerInjector&lt;/code&gt;来从&lt;code&gt;providerCache&lt;/code&gt;里拿相应的&lt;code&gt;provider&lt;/code&gt;。
在获取provider之后调用了&lt;code&gt;invoke&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return instanceInjector.invoke(
                    provider.$get, provider, undefined, serviceName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看一下&lt;code&gt;invoke&lt;/code&gt;的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function injectionArgs(fn, locals, serviceName) {
      var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName);

      for (var i = 0, length = $inject.length; i &amp;lt; length; i++) {
        var key = $inject[i];
        if (typeof key !== &#39;string&#39;) {
          throw $injectorMinErr(&#39;itkn&#39;,
                  &#39;Incorrect injection token! Expected service name as string, got {0}&#39;, key);
        }
        //这里最终返回的args是$inject对应的provider对象的列表
        args.push(locals &amp;amp;&amp;amp; locals.hasOwnProperty(key) ? locals[key] :
                                                         getService(key, serviceName));
      }
      return args;
    }
    function invoke(fn, self, locals, serviceName) {
      if (typeof locals === &#39;string&#39;) {
        serviceName = locals;
        locals = null;
      }

      var args = injectionArgs(fn, locals, serviceName);
      if (isArray(fn)) {
        fn = fn[fn.length - 1];
      }

      if (!isClass(fn)) {
        // http://jsperf.com/angularjs-invoke-apply-vs-switch
        // #5388
        return fn.apply(self, args);
      } else {
        args.unshift(null);
        //这里有一点绕，args中unshift一个null是用于占thisArg的位，由于new操作符，该参数无效
        //以下相当于以fn为构造函数进行new操作，并将不带null的args spread开作为参数传递
        //在instantiate中也有类似的方式
        return new (Function.prototype.bind.apply(fn, args))();
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以可以看出，&lt;code&gt;invoke&lt;/code&gt;将会得到一个切实可用的&lt;code&gt;service&lt;/code&gt;，并在获取的过程中进行了缓存以及将所有的需求的依赖进行注入。&lt;/p&gt;

&lt;p&gt;整理一下流程就是，&lt;code&gt;instanceInjector&lt;/code&gt;通过调用get，可以从&lt;code&gt;instanceCache&lt;/code&gt;中获取已经初始化的service，如果instanceCache中没有，
就从&lt;code&gt;providerCache&lt;/code&gt;中获取其provider定义，然后初始化再缓存至instanceCache中，并返回初始化好的service。&lt;/p&gt;

&lt;h2 id=&#34;再回到createinjector&#34;&gt;再回到createInjector&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;现在，我们已经弄清楚了injector的工作原理了，在返回instanceInjector之前，还调用了一句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var runBlocks = loadModules(modulesToLoad);
    //省略
    forEach(runBlocks, function(fn) { if (fn) instanceInjector.invoke(fn); });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显而易见这是将所有需要加载的module进行了invoke，我们来看看loadModules的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function loadModules(modulesToLoad) {
        assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), &#39;modulesToLoad&#39;, &#39;not an array&#39;);
        var runBlocks = [], moduleFn;
        forEach(modulesToLoad, function(module) {
          //如果模块已经加载，直接返回
          if (loadedModules.get(module)) return;
          //没有加载时，设置为已加载，并继续执行
          loadedModules.put(module, true);
          //执行invoke队列的函数声明
          function runInvokeQueue(queue) {
            var i, ii;
            for (i = 0, ii = queue.length; i &amp;lt; ii; i++) {
              var invokeArgs = queue[i],
                  provider = providerInjector.get(invokeArgs[0]);
    
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          }
    
          try {
            if (isString(module)) {
              moduleFn = angularModule(module);
              runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
              //执行invoke队列
              runInvokeQueue(moduleFn._invokeQueue);
              runInvokeQueue(moduleFn._configBlocks);
            } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
            } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
            } else {
              assertArgFn(module, &#39;module&#39;);
            }
          } catch (e) {
            if (isArray(module)) {
              module = module[module.length - 1];
            }
            if (e.message &amp;amp;&amp;amp; e.stack &amp;amp;&amp;amp; e.stack.indexOf(e.message) === -1) {
              // Safari &amp;amp; FF&#39;s stack traces don&#39;t contain error.message content
              // unlike those of Chrome and IE
              // So if stack doesn&#39;t contain message, we create a new string that contains both.
              // Since error.stack is read-only in Safari, I&#39;m overriding e and not e.stack here.
              // eslint-disable-next-line no-ex-assign
              e = e.message + &#39;\n&#39; + e.stack;
            }
            throw $injectorMinErr(&#39;modulerr&#39;, &#39;Failed to instantiate module {0} due to:\n{1}&#39;,
                      module, e.stack || e.message || e);
          }
        });
        return runBlocks;
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，涉及到了很多angularModule方面的概念，其相关定义都在loader.js中，在module相关章节展开时再做解读，
包括modulesToLoad的格式，module的invoke。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Angular1 Source Code Overview</title>
      <link>http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/</link>
      <pubDate>Thu, 15 Dec 2016 10:18:34 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/</guid>
      <description>&lt;p&gt;基于版本：1.6.0&lt;/p&gt;

&lt;h2 id=&#34;概念解读&#34;&gt;概念解读&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;先来搬运一下官方的doc&lt;/p&gt;

&lt;p&gt;其中介绍了一些框架内的重要概念
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Concept&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Template&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;HTML with additional markup&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Directives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extend HTML with custom attributes and elements&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Model&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the data shown to the user in the view and with which the user interacts&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Scope&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;context where the model is stored so that controllers, directives and expressions can access it&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Expressions&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;access variables and functions from the scope&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Compiler&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;parses the template and instantiates directives and expressions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Filter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;formats the value of an expression for display to the user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;View&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;what the user sees (the DOM)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Data Binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sync data between the model and the view&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Controller&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the business logic behind views&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Dependency Injection&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Creates and wires objects and functions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Injector&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dependency injection container&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Module&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;a container for the different parts of an app including controllers, services, filters, directives which configures the Injector&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Service&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;reusable business logic independent of views&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;这些概念存在的意义&#34;&gt;这些概念存在的意义&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;一个简单的例子&#34;&gt;一个简单的例子&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/beedjLQy1AqlCcgcixuN/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这看起来很像普通的html，加上一些新的标记。在angular中，以这样的形式组织的语句叫做模版。
当Angular启动应用时，它会使用&lt;code&gt;compiler&lt;/code&gt;来转化和处理&lt;code&gt;template&lt;/code&gt;中的新标记。
加载、转化和渲染后的DOM称之为&lt;code&gt;view&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第一种新标记称之为&lt;code&gt;directives&lt;/code&gt;。它们将特殊的行为应用到HTML中的attributes或者elements中。
在这个例子中，我们使用了&lt;code&gt;ng-app&lt;/code&gt;，它用来连接一个&lt;code&gt;directive&lt;/code&gt;来实例化我们的应用。
Angular自身还为&lt;code&gt;input&lt;/code&gt;元素定义了一个directive来扩展该元素的行为。
&lt;code&gt;ng-model&lt;/code&gt;这个directive用来在变量和input filed中同步数据展示，即一个双向绑定。
值得注意的是，在Angular中，&lt;code&gt;directive&lt;/code&gt;是唯一一个可以直接接触DOM的地方。&lt;/p&gt;

&lt;p&gt;第二种新的标记形如&lt;code&gt;{{ expression | filter }}&lt;/code&gt;，当compiler遇到这样的标记时，会用最终的计算结果来代替它。
expression是一个js形式的代码语句，可以读写在该&lt;code&gt;scope&lt;/code&gt;中存活的变量。存储在scope中的变量称之为&lt;code&gt;model&lt;/code&gt;。
这个例子还包含了一个&lt;code&gt;filter&lt;/code&gt;，一个过滤器将数据格式化后展现给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-databinding1.png&#34; alt=&#34;concepts-databinding1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子展现了Angular的一个重要的绑定概念：无论何时当input的value发生了变化，expression中的value也会自动重新计算，
并且将结果更新到DOM中去，这个概念称之为双向数据绑定。&lt;/p&gt;

&lt;h3 id=&#34;一个controller的例子&#34;&gt;一个controller的例子&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/ICBcjB5SPnwqOUaegQQg/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们引入了&lt;code&gt;controller&lt;/code&gt;，使用controller的目的是为了将一些变量和功能性的方法暴露给&lt;code&gt;expressions&lt;/code&gt;和&lt;code&gt;directives&lt;/code&gt;。
我们在HTML中使用了&lt;code&gt;ng-controller&lt;/code&gt;这个directive，这个directive告诉Angular一个新的&lt;code&gt;InvoiceController&lt;/code&gt;负责处理存在该directive的元素以及其下的所有子元素。
语句&lt;code&gt;InvoiceController as invoice&lt;/code&gt;告诉Angular实例化该controller并且用变量&lt;code&gt;invoice&lt;/code&gt;来存储到当前的scope中。
于是可以在template里通过invoice来调用controller的变量和方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-databinding2.png&#34; alt=&#34;concepts-databinding2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;service-与视图无关的业务逻辑&#34;&gt;service：与视图无关的业务逻辑&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/bJ7Ci5uRFycAnuup7n9I/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上一个例子中，&lt;code&gt;controller&lt;/code&gt;包含了所有的逻辑。然而当我们的应用不断增长壮大之后，一个良好的实践是将与视图无关的业务逻辑
抽离到&lt;code&gt;service&lt;/code&gt;中去，这使得这些方法可以被应用的其他部分进行复用。
我们将&lt;code&gt;convertCurrency&lt;/code&gt;和相关的定义移到了service中，但是controller是怎样获取并使用到一个已经分离出去的方法的呢？&lt;/p&gt;

&lt;p&gt;这就是&lt;code&gt;Dependency Injection&lt;/code&gt;发挥作用的地方了。
DI是一种软件设计模式，用来处理对象和方法的创建以及确保它们得到它们的依赖。
Angular中的一切（directives,filters,controllers,services,&amp;hellip;）都是通过DI创建并且管理的。
在Angular里，DI的容器称之为&lt;code&gt;Injector&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-module-injector.png&#34; alt=&#34;concepts-module-injector&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了使用DI，需要有一个地方使得所有事物一起工作并且注册，这就是在Angular中使用&lt;code&gt;modules&lt;/code&gt;的目的。
当Angular启动时，它会使用具有&lt;code&gt;ng-app&lt;/code&gt;这一directive定义的名称的module的配置，
同时包含了该module所依赖的所有modules的配置。&lt;/p&gt;

&lt;p&gt;在上述的例子中，这个template包含了directive &lt;code&gt;ng-app=&amp;quot;invoice2&amp;quot;&lt;/code&gt;。这告诉Angular使用&lt;code&gt;invoice2&lt;/code&gt;
module作为本应用的主module。&lt;code&gt;angular.module(&amp;quot;invoice2&amp;quot;,[&amp;quot;finance2&amp;quot;])&lt;/code&gt;表明了&lt;code&gt;invoice2&lt;/code&gt;module依赖于
&lt;code&gt;finance2&lt;/code&gt;模块，通过这个，Angular使用&lt;code&gt;InvoiceController&lt;/code&gt;以及&lt;code&gt;currencyConverter&lt;/code&gt;服务。&lt;/p&gt;

&lt;p&gt;现在Angular知道了应用的所有部分，需要去创建它们。在前面我们知道controllers通过构造方法来创建。
至于services，有很多种方法来指定它们的创建方式，在上述的例子中，我们使用&lt;code&gt;factory&lt;/code&gt;来创建&lt;code&gt;currencyConverter&lt;/code&gt;，
此函数应该要返回currencyConverter service实例。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里牵扯到 factory和service的区别，factory最终需要显式返回一个实例，而service会以构造函数的形式创建服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-module-service.png&#34; alt=&#34;concepts-module-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回到最初的问题，InvoiceController是怎样获得currencyConverter的引用的？
在Angular中，通过简单的在构造方法中定义arguments就可以做到。通过这种方式，&lt;code&gt;injector&lt;/code&gt;就能够以正确的顺序
创建对象，并且将先前创建的对象传递到依赖于它们的对象的工厂中。在上述的例子中，InvoiceController有一个argument叫做
currencyConverter，通过这个，Angular就知道了controller和service之间的依赖关系，并且通过该service的实例来调用controller的构造函数进行实例化。&lt;/p&gt;

&lt;p&gt;至于我们在module.controller中传递了一个数组，是为了使得代码在经过压缩和uglify之后仍然能够正常工作的机制，因为这样arguments可能会被&lt;code&gt;a&lt;/code&gt;这样的变量名替代。&lt;/p&gt;

&lt;h3 id=&#34;data-binding&#34;&gt;Data Binding&lt;/h3&gt;

&lt;p&gt;数据绑定在传统的模板系统中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/One_Way_Data_Binding.png&#34; alt=&#34;One_Way_Data_Binding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数据绑定在Angular模板系统中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/Two_Way_Data_Binding.png&#34; alt=&#34;Two_Way_Data_Binding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但也因此要特别注意不要造成死循环&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Queue Reconstruction by Height</title>
      <link>http://harveyprince.github.io/blog/post/QueueReconstructionbyHeight/</link>
      <pubDate>Thu, 20 Oct 2016 21:30:00 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/QueueReconstructionbyHeight/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers &lt;code&gt;(h, k)&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; is the height of the person and &lt;code&gt;k&lt;/code&gt; is the number of people in front of this person who have a height greater than or equal to &lt;code&gt;h&lt;/code&gt;. Write an algorithm to reconstruct the queue.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The number of people is less than &lt;code&gt;1,100&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function(people) {
    //先根据h从大到小进行排序，h相同的，根据k从小到大排序
    people.sort((a,b)=&amp;gt;a[0]===b[0]?a[1]-b[1]:b[0]-a[0]);
    people.unshift([]);
    //k代表在其前面比他高的个数，由于已经根据高度排过序，所以直接在该位置插入该元素即可
    return people.reduce((list,next)=&amp;gt;{
        list.splice(next[1],0,next);
        return list;
    });
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Battle ships in a Board</title>
      <link>http://harveyprince.github.io/blog/post/BattleshipsinaBoard/</link>
      <pubDate>Thu, 20 Oct 2016 21:08:32 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/BattleshipsinaBoard/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Given an 2D board, count how many different battleships are in it. The battleships are represented with &lt;code&gt;&#39;X&#39;&lt;/code&gt;s, empty slots are represented with &lt;code&gt;&#39;.&#39;&lt;/code&gt;s. You may assume the following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You receive a valid board, made of only battleships or empty slots.&lt;/li&gt;
&lt;li&gt;Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape &lt;code&gt;1xN&lt;/code&gt; (1 row, N columns) or &lt;code&gt;Nx1&lt;/code&gt; (N rows, 1 column), where N can be of any size.&lt;/li&gt;
&lt;li&gt;At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X..X
...X
...X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above board there are 2 battleships.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...X
XXXX
...X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not a valid board - as battleships will always have a cell separating between them.
Your algorithm should not modify the value of the board.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {character[][]} board
 * @return {number}
 */
var countBattleships = function(board) {
    let width = board[0].length;
    let height = board.length;
    let tag_num = 0;
    for (let i = 0; i &amp;lt; height; i ++) {
        for (let j = 0; j &amp;lt; width; j ++) {
            let cell = board[i][j];
            if (cell == &#39;.&#39;) {
                continue;
            }
            if (cell == &#39;X&#39; &amp;amp;&amp;amp; 
            (i == 0 || board[i-1][j] == &#39;.&#39; )&amp;amp;&amp;amp;
            ( j == 0 || board[i][j-1] == &#39;.&#39; ) ) {
                //找到一个船的部分，并且左方和上方无其余部分的时候累加
                tag_num ++;
            }
        }
    }
    return tag_num;
};

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Reverse String</title>
      <link>http://harveyprince.github.io/blog/post/ReverseString/</link>
      <pubDate>Thu, 20 Oct 2016 13:14:18 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/ReverseString/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;s = &amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;return &amp;quot;olleh&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;最简单的方式就是让指针从末尾一直指向0，将指针位置的char累加至一个变量里&lt;/p&gt;

&lt;p&gt;改进的做法是采用两个指针，一个从头开始，一个从尾开始，交换两个指针位置的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {string} s
 * @return {string}
 */
var reverseString = function(s) {
    let left = &#39;&#39;;
    let right = &#39;&#39;;
    for (var i = s.length-1,j=0; i &amp;gt; j; i--,j++) {
        right = s[j] + right;
        left += s[i];
    }
    
    return left + (i==j?s[i]:&#39;&#39;) + right;
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Fizz Buzz</title>
      <link>http://harveyprince.github.io/blog/post/FizzBuzz/</link>
      <pubDate>Thu, 20 Oct 2016 12:37:17 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/FizzBuzz/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Write a program that outputs the string representation of numbers from 1 to n.&lt;/p&gt;

&lt;p&gt;But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 15,

Return:
[
    &amp;quot;1&amp;quot;,
    &amp;quot;2&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;4&amp;quot;,
    &amp;quot;Buzz&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;7&amp;quot;,
    &amp;quot;8&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;Buzz&amp;quot;,
    &amp;quot;11&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;13&amp;quot;,
    &amp;quot;14&amp;quot;,
    &amp;quot;FizzBuzz&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var res = [];
    for (let i = 1; i &amp;lt;=n ; i++) {
        let name = &#39;&#39;;
        i%3 == 0?name+=&#39;Fizz&#39;:&#39;&#39;;
        i%5 == 0?name+=&#39;Buzz&#39;:&#39;&#39;;
        res.push(name==&#39;&#39;?i .toString():name);
    }
    return res;
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Number of 1 Bits</title>
      <link>http://harveyprince.github.io/blog/post/Numberof1Bits/</link>
      <pubDate>Thu, 20 Oct 2016 11:19:14 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/Numberof1Bits/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Write a function that takes an unsigned integer and returns the number of &lt;code&gt;’1&#39;&lt;/code&gt; bits it has (also known as the Hamming weight).&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;32-bit&lt;/code&gt; integer &lt;code&gt;’11&#39;&lt;/code&gt; has binary representation &lt;code&gt;00000000000000000000000000001011&lt;/code&gt;, so the function should &lt;code&gt;return 3&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;最简单的做法就是将所有位的0或1加起来就是最终结果，这里就不赘述了&lt;/p&gt;

&lt;p&gt;方法1:
通过正则进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    return (n).toString(2).replace(/0/g, &#39;&#39;).length;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法2:
通过位操作符进行&lt;/p&gt;

&lt;p&gt;通过研究可以知道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;假设
  n        =&amp;gt;    11000
  n-1      =&amp;gt;    10111

  则
  n &amp;amp; n-1  =&amp;gt;    10000

  就可以做到从右往左逐渐将1抹去      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到解法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let count = 0;
    while(n!=0){
        count ++;
        n &amp;amp;= (n-1);
    }
    return count;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实验证明正则的处理更快&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Counting Bits</title>
      <link>http://harveyprince.github.io/blog/post/CountingBits/</link>
      <pubDate>Thu, 20 Oct 2016 09:56:13 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/CountingBits/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Given a non negative integer number num. For every numbers i in the range &lt;code&gt;0 ≤ i ≤ num&lt;/code&gt; calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;
For &lt;code&gt;num = 5&lt;/code&gt; you should &lt;code&gt;return [0,1,1,2,1,2]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Follow up:&lt;/p&gt;

&lt;p&gt;It is very easy to come up with a solution with run time &lt;code&gt;O(n*sizeof(integer))&lt;/code&gt;. But can you do it in linear time &lt;code&gt;O(n)&lt;/code&gt; /possibly in a single pass?
Space complexity should be &lt;code&gt;O(n)&lt;/code&gt;.
Can you do it like a boss? Do it without using any builtin function like &lt;code&gt;__builtin_popcount&lt;/code&gt; in c++ or in any other language.&lt;/p&gt;

&lt;p&gt;Hint:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You should make use of what you have produced already.&lt;/li&gt;
&lt;li&gt;Divide the numbers in ranges like &lt;code&gt;[2-3]&lt;/code&gt;, &lt;code&gt;[4-7]&lt;/code&gt;, &lt;code&gt;[8-15]&lt;/code&gt; and so on. And try to generate new range from previous.&lt;/li&gt;
&lt;li&gt;Or does the odd/even status of the number help you in calculating the number of 1s?&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;根据提示可以知道&lt;code&gt;[2-3]&lt;/code&gt;为&lt;code&gt;[10,11]&lt;/code&gt;，&lt;code&gt;[4-7]&lt;/code&gt;为&lt;code&gt;[100,111]&lt;/code&gt;，可以看出范围的划分为&lt;code&gt;2^n ~ 2^(n+1)-1&lt;/code&gt;，要利用已有的结果，即&lt;code&gt;1**&lt;/code&gt;实际上是在&lt;code&gt;**&lt;/code&gt;的基础上加了&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;1*&lt;/code&gt;又是在&lt;code&gt;*&lt;/code&gt;的基础上加&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;num = 5&lt;/code&gt;的结果为&lt;code&gt;[0,1,1,2,1,2]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0  1
    0  1  (0  1)+1  =  0  1  1  2
    0  1  1  2  (0  1  1  2)+1 = 0  1  1  2  1  2  2  3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下解法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    var border = 1;
    var arr = [0];
    for (let i = 1;i&amp;lt;=num ;i++) {
        
        if (i &amp;gt;= border) {
            let idx = i - border;
            arr.push(arr[idx]+1);
            if (i == 2*border-1) {
                border *= 2;
            }
        }
        
    }
    
    return arr;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以考虑成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 7 =&amp;gt; 111     &amp;gt;&amp;gt;&amp;gt;1      右移一位  成了 11（即3）  ，3所包含的1的数量再加上最末位的数值（0或1）就是结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    var arr = [0];
    for (let i = 1;i&amp;lt;=num ;i++) {
        
        arr.push(arr[i&amp;gt;&amp;gt;&amp;gt;1]+(i&amp;amp;1));
        
    }
    
    return arr;
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
