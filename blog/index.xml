<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jason Lab</title>
    <link>http://harveyprince.github.io/blog/index.xml</link>
    <description>Recent content on Jason Lab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Jason</copyright>
    <lastBuildDate>Thu, 15 Dec 2016 10:18:34 +0800</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Angular1 Source Code Overview</title>
      <link>http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/</link>
      <pubDate>Thu, 15 Dec 2016 10:18:34 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/AngularjsSourceCodeOverview/</guid>
      <description>&lt;p&gt;基于版本：1.6.0&lt;/p&gt;

&lt;h2 id=&#34;概念解读&#34;&gt;概念解读&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;先来搬运一下官方的doc&lt;/p&gt;

&lt;p&gt;其中介绍了一些框架内的重要概念
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Concept&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Template&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;HTML with additional markup&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Directives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extend HTML with custom attributes and elements&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Model&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the data shown to the user in the view and with which the user interacts&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Scope&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;context where the model is stored so that controllers, directives and expressions can access it&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Expressions&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;access variables and functions from the scope&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Compiler&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;parses the template and instantiates directives and expressions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Filter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;formats the value of an expression for display to the user&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;View&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;what the user sees (the DOM)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Data Binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sync data between the model and the view&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Controller&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the business logic behind views&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Dependency Injection&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Creates and wires objects and functions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Injector&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dependency injection container&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Module&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;a container for the different parts of an app including controllers, services, filters, directives which configures the Injector&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Service&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;reusable business logic independent of views&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;这些概念存在的意义&#34;&gt;这些概念存在的意义&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;一个简单的例子&#34;&gt;一个简单的例子&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/beedjLQy1AqlCcgcixuN/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这看起来很像普通的html，加上一些新的标记。在angular中，以这样的形式组织的语句叫做模版。
当Angular启动应用时，它会使用&lt;code&gt;compiler&lt;/code&gt;来转化和处理&lt;code&gt;template&lt;/code&gt;中的新标记。
加载、转化和渲染后的DOM称之为&lt;code&gt;view&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第一种新标记称之为&lt;code&gt;directives&lt;/code&gt;。它们将特殊的行为应用到HTML中的attributes或者elements中。
在这个例子中，我们使用了&lt;code&gt;ng-app&lt;/code&gt;，它用来连接一个&lt;code&gt;directive&lt;/code&gt;来实例化我们的应用。
Angular自身还为&lt;code&gt;input&lt;/code&gt;元素定义了一个directive来扩展该元素的行为。
&lt;code&gt;ng-model&lt;/code&gt;这个directive用来在变量和input filed中同步数据展示，即一个双向绑定。
值得注意的是，在Angular中，&lt;code&gt;directive&lt;/code&gt;是唯一一个可以直接接触DOM的地方。&lt;/p&gt;

&lt;p&gt;第二种新的标记形如&lt;code&gt;{{ expression | filter }}&lt;/code&gt;，当compiler遇到这样的标记时，会用最终的计算结果来代替它。
expression是一个js形式的代码语句，可以读写在该&lt;code&gt;scope&lt;/code&gt;中存活的变量。存储在scope中的变量称之为&lt;code&gt;model&lt;/code&gt;。
这个例子还包含了一个&lt;code&gt;filter&lt;/code&gt;，一个过滤器将数据格式化后展现给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-databinding1.png&#34; alt=&#34;concepts-databinding1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子展现了Angular的一个重要的绑定概念：无论何时当input的value发生了变化，expression中的value也会自动重新计算，
并且将结果更新到DOM中去，这个概念称之为双向数据绑定。&lt;/p&gt;

&lt;h3 id=&#34;一个controller的例子&#34;&gt;一个controller的例子&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/ICBcjB5SPnwqOUaegQQg/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们引入了&lt;code&gt;controller&lt;/code&gt;，使用controller的目的是为了将一些变量和功能性的方法暴露给&lt;code&gt;expressions&lt;/code&gt;和&lt;code&gt;directives&lt;/code&gt;。
我们在HTML中使用了&lt;code&gt;ng-controller&lt;/code&gt;这个directive，这个directive告诉Angular一个新的&lt;code&gt;InvoiceController&lt;/code&gt;负责处理存在该directive的元素以及其下的所有子元素。
语句&lt;code&gt;InvoiceController as invoice&lt;/code&gt;告诉Angular实例化该controller并且用变量&lt;code&gt;invoice&lt;/code&gt;来存储到当前的scope中。
于是可以在template里通过invoice来调用controller的变量和方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-databinding2.png&#34; alt=&#34;concepts-databinding2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;service-与视图无关的业务逻辑&#34;&gt;service：与视图无关的业务逻辑&lt;/h3&gt;

&lt;p&gt;&lt;embed width=&#34;100%&#34; height=&#34;500&#34; src=&#34;https://embed.plnkr.co/bJ7Ci5uRFycAnuup7n9I/&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上一个例子中，&lt;code&gt;controller&lt;/code&gt;包含了所有的逻辑。然而当我们的应用不断增长壮大之后，一个良好的实践是将与视图无关的业务逻辑
抽离到&lt;code&gt;service&lt;/code&gt;中去，这使得这些方法可以被应用的其他部分进行复用。
我们将&lt;code&gt;convertCurrency&lt;/code&gt;和相关的定义移到了service中，但是controller是怎样获取并使用到一个已经分离出去的方法的呢？&lt;/p&gt;

&lt;p&gt;这就是&lt;code&gt;Dependency Injection&lt;/code&gt;发挥作用的地方了。
DI是一种软件设计模式，用来处理对象和方法的创建以及确保它们得到它们的依赖。
Angular中的一切（directives,filters,controllers,services,&amp;hellip;）都是通过DI创建并且管理的。
在Angular里，DI的容器称之为&lt;code&gt;Injector&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-module-injector.png&#34; alt=&#34;concepts-module-injector&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了使用DI，需要有一个地方使得所有事物一起工作并且注册，这就是在Angular中使用&lt;code&gt;modules&lt;/code&gt;的目的。
当Angular启动时，它会使用具有&lt;code&gt;ng-app&lt;/code&gt;这一directive定义的名称的module的配置，
同时包含了该module所依赖的所有modules的配置。&lt;/p&gt;

&lt;p&gt;在上述的例子中，这个template包含了directive &lt;code&gt;ng-app=&amp;quot;invoice2&amp;quot;&lt;/code&gt;。这告诉Angular使用&lt;code&gt;invoice2&lt;/code&gt;
module作为本应用的主module。&lt;code&gt;angular.module(&amp;quot;invoice2&amp;quot;,[&amp;quot;finance2&amp;quot;])&lt;/code&gt;表明了&lt;code&gt;invoice2&lt;/code&gt;module依赖于
&lt;code&gt;finance2&lt;/code&gt;模块，通过这个，Angular使用&lt;code&gt;InvoiceController&lt;/code&gt;以及&lt;code&gt;currencyConverter&lt;/code&gt;服务。&lt;/p&gt;

&lt;p&gt;现在Angular知道了应用的所有部分，需要去创建它们。在前面我们知道controllers通过构造方法来创建。
至于services，有很多种方法来指定它们的创建方式，在上述的例子中，我们使用&lt;code&gt;factory&lt;/code&gt;来创建&lt;code&gt;currencyConverter&lt;/code&gt;，
此函数应该要返回currencyConverter service实例。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里牵扯到 factory和service的区别，factory最终需要显式返回一个实例，而service会以构造函数的形式创建服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/concepts-module-service.png&#34; alt=&#34;concepts-module-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回到最初的问题，InvoiceController是怎样获得currencyConverter的引用的？
在Angular中，通过简单的在构造方法中定义arguments就可以做到。通过这种方式，&lt;code&gt;injector&lt;/code&gt;就能够以正确的顺序
创建对象，并且将先前创建的对象传递到依赖于它们的对象的工厂中。在上述的例子中，InvoiceController有一个argument叫做
currencyConverter，通过这个，Angular就知道了controller和service之间的依赖关系，并且通过该service的实例来调用controller的构造函数进行实例化。&lt;/p&gt;

&lt;p&gt;至于我们在module.controller中传递了一个数组，是为了使得代码在经过压缩和uglify之后仍然能够正常工作的机制，因为这样arguments可能会被&lt;code&gt;a&lt;/code&gt;这样的变量名替代。&lt;/p&gt;

&lt;h3 id=&#34;data-binding&#34;&gt;Data Binding&lt;/h3&gt;

&lt;p&gt;数据绑定在传统的模板系统中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/One_Way_Data_Binding.png&#34; alt=&#34;One_Way_Data_Binding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数据绑定在Angular模板系统中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://harveyprince.github.io/blog/blog/img/post/AngularjsSourceCodeOverview/Two_Way_Data_Binding.png&#34; alt=&#34;Two_Way_Data_Binding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但也因此要特别注意不要造成死循环&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Queue Reconstruction by Height</title>
      <link>http://harveyprince.github.io/blog/post/QueueReconstructionbyHeight/</link>
      <pubDate>Thu, 20 Oct 2016 21:30:00 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/QueueReconstructionbyHeight/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers &lt;code&gt;(h, k)&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; is the height of the person and &lt;code&gt;k&lt;/code&gt; is the number of people in front of this person who have a height greater than or equal to &lt;code&gt;h&lt;/code&gt;. Write an algorithm to reconstruct the queue.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The number of people is less than &lt;code&gt;1,100&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function(people) {
    //先根据h从大到小进行排序，h相同的，根据k从小到大排序
    people.sort((a,b)=&amp;gt;a[0]===b[0]?a[1]-b[1]:b[0]-a[0]);
    people.unshift([]);
    //k代表在其前面比他高的个数，由于已经根据高度排过序，所以直接在该位置插入该元素即可
    return people.reduce((list,next)=&amp;gt;{
        list.splice(next[1],0,next);
        return list;
    });
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Battle ships in a Board</title>
      <link>http://harveyprince.github.io/blog/post/BattleshipsinaBoard/</link>
      <pubDate>Thu, 20 Oct 2016 21:08:32 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/BattleshipsinaBoard/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Given an 2D board, count how many different battleships are in it. The battleships are represented with &lt;code&gt;&#39;X&#39;&lt;/code&gt;s, empty slots are represented with &lt;code&gt;&#39;.&#39;&lt;/code&gt;s. You may assume the following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You receive a valid board, made of only battleships or empty slots.&lt;/li&gt;
&lt;li&gt;Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape &lt;code&gt;1xN&lt;/code&gt; (1 row, N columns) or &lt;code&gt;Nx1&lt;/code&gt; (N rows, 1 column), where N can be of any size.&lt;/li&gt;
&lt;li&gt;At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X..X
...X
...X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above board there are 2 battleships.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...X
XXXX
...X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not a valid board - as battleships will always have a cell separating between them.
Your algorithm should not modify the value of the board.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {character[][]} board
 * @return {number}
 */
var countBattleships = function(board) {
    let width = board[0].length;
    let height = board.length;
    let tag_num = 0;
    for (let i = 0; i &amp;lt; height; i ++) {
        for (let j = 0; j &amp;lt; width; j ++) {
            let cell = board[i][j];
            if (cell == &#39;.&#39;) {
                continue;
            }
            if (cell == &#39;X&#39; &amp;amp;&amp;amp; 
            (i == 0 || board[i-1][j] == &#39;.&#39; )&amp;amp;&amp;amp;
            ( j == 0 || board[i][j-1] == &#39;.&#39; ) ) {
                //找到一个船的部分，并且左方和上方无其余部分的时候累加
                tag_num ++;
            }
        }
    }
    return tag_num;
};

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Reverse String</title>
      <link>http://harveyprince.github.io/blog/post/ReverseString/</link>
      <pubDate>Thu, 20 Oct 2016 13:14:18 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/ReverseString/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;s = &amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;return &amp;quot;olleh&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;最简单的方式就是让指针从末尾一直指向0，将指针位置的char累加至一个变量里&lt;/p&gt;

&lt;p&gt;改进的做法是采用两个指针，一个从头开始，一个从尾开始，交换两个指针位置的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {string} s
 * @return {string}
 */
var reverseString = function(s) {
    let left = &#39;&#39;;
    let right = &#39;&#39;;
    for (var i = s.length-1,j=0; i &amp;gt; j; i--,j++) {
        right = s[j] + right;
        left += s[i];
    }
    
    return left + (i==j?s[i]:&#39;&#39;) + right;
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Fizz Buzz</title>
      <link>http://harveyprince.github.io/blog/post/FizzBuzz/</link>
      <pubDate>Thu, 20 Oct 2016 12:37:17 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/FizzBuzz/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Write a program that outputs the string representation of numbers from 1 to n.&lt;/p&gt;

&lt;p&gt;But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 15,

Return:
[
    &amp;quot;1&amp;quot;,
    &amp;quot;2&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;4&amp;quot;,
    &amp;quot;Buzz&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;7&amp;quot;,
    &amp;quot;8&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;Buzz&amp;quot;,
    &amp;quot;11&amp;quot;,
    &amp;quot;Fizz&amp;quot;,
    &amp;quot;13&amp;quot;,
    &amp;quot;14&amp;quot;,
    &amp;quot;FizzBuzz&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var res = [];
    for (let i = 1; i &amp;lt;=n ; i++) {
        let name = &#39;&#39;;
        i%3 == 0?name+=&#39;Fizz&#39;:&#39;&#39;;
        i%5 == 0?name+=&#39;Buzz&#39;:&#39;&#39;;
        res.push(name==&#39;&#39;?i .toString():name);
    }
    return res;
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Number of 1 Bits</title>
      <link>http://harveyprince.github.io/blog/post/Numberof1Bits/</link>
      <pubDate>Thu, 20 Oct 2016 11:19:14 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/Numberof1Bits/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Write a function that takes an unsigned integer and returns the number of &lt;code&gt;’1&#39;&lt;/code&gt; bits it has (also known as the Hamming weight).&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;32-bit&lt;/code&gt; integer &lt;code&gt;’11&#39;&lt;/code&gt; has binary representation &lt;code&gt;00000000000000000000000000001011&lt;/code&gt;, so the function should &lt;code&gt;return 3&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;最简单的做法就是将所有位的0或1加起来就是最终结果，这里就不赘述了&lt;/p&gt;

&lt;p&gt;方法1:
通过正则进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    return (n).toString(2).replace(/0/g, &#39;&#39;).length;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法2:
通过位操作符进行&lt;/p&gt;

&lt;p&gt;通过研究可以知道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;假设
  n        =&amp;gt;    11000
  n-1      =&amp;gt;    10111

  则
  n &amp;amp; n-1  =&amp;gt;    10000

  就可以做到从右往左逐渐将1抹去      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到解法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let count = 0;
    while(n!=0){
        count ++;
        n &amp;amp;= (n-1);
    }
    return count;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实验证明正则的处理更快&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Counting Bits</title>
      <link>http://harveyprince.github.io/blog/post/CountingBits/</link>
      <pubDate>Thu, 20 Oct 2016 09:56:13 +0800</pubDate>
      
      <guid>http://harveyprince.github.io/blog/post/CountingBits/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Given a non negative integer number num. For every numbers i in the range &lt;code&gt;0 ≤ i ≤ num&lt;/code&gt; calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;
For &lt;code&gt;num = 5&lt;/code&gt; you should &lt;code&gt;return [0,1,1,2,1,2]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Follow up:&lt;/p&gt;

&lt;p&gt;It is very easy to come up with a solution with run time &lt;code&gt;O(n*sizeof(integer))&lt;/code&gt;. But can you do it in linear time &lt;code&gt;O(n)&lt;/code&gt; /possibly in a single pass?
Space complexity should be &lt;code&gt;O(n)&lt;/code&gt;.
Can you do it like a boss? Do it without using any builtin function like &lt;code&gt;__builtin_popcount&lt;/code&gt; in c++ or in any other language.&lt;/p&gt;

&lt;p&gt;Hint:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You should make use of what you have produced already.&lt;/li&gt;
&lt;li&gt;Divide the numbers in ranges like &lt;code&gt;[2-3]&lt;/code&gt;, &lt;code&gt;[4-7]&lt;/code&gt;, &lt;code&gt;[8-15]&lt;/code&gt; and so on. And try to generate new range from previous.&lt;/li&gt;
&lt;li&gt;Or does the odd/even status of the number help you in calculating the number of 1s?&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;根据提示可以知道&lt;code&gt;[2-3]&lt;/code&gt;为&lt;code&gt;[10,11]&lt;/code&gt;，&lt;code&gt;[4-7]&lt;/code&gt;为&lt;code&gt;[100,111]&lt;/code&gt;，可以看出范围的划分为&lt;code&gt;2^n ~ 2^(n+1)-1&lt;/code&gt;，要利用已有的结果，即&lt;code&gt;1**&lt;/code&gt;实际上是在&lt;code&gt;**&lt;/code&gt;的基础上加了&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;1*&lt;/code&gt;又是在&lt;code&gt;*&lt;/code&gt;的基础上加&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;num = 5&lt;/code&gt;的结果为&lt;code&gt;[0,1,1,2,1,2]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0  1
    0  1  (0  1)+1  =  0  1  1  2
    0  1  1  2  (0  1  1  2)+1 = 0  1  1  2  1  2  2  3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下解法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    var border = 1;
    var arr = [0];
    for (let i = 1;i&amp;lt;=num ;i++) {
        
        if (i &amp;gt;= border) {
            let idx = i - border;
            arr.push(arr[idx]+1);
            if (i == 2*border-1) {
                border *= 2;
            }
        }
        
    }
    
    return arr;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以考虑成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 7 =&amp;gt; 111     &amp;gt;&amp;gt;&amp;gt;1      右移一位  成了 11（即3）  ，3所包含的1的数量再加上最末位的数值（0或1）就是结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    var arr = [0];
    for (let i = 1;i&amp;lt;=num ;i++) {
        
        arr.push(arr[i&amp;gt;&amp;gt;&amp;gt;1]+(i&amp;amp;1));
        
    }
    
    return arr;
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>waiting for project</title>
      <link>http://harveyprince.github.io/blog/project/deep-learning/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://harveyprince.github.io/blog/project/deep-learning/</guid>
      <description>&lt;p&gt;waiting&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
